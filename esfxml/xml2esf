#!/usr/bin/env ruby

require 'rubygems'
require "nokogiri"
require "esf_builder"
require "pp"
require "pgm"

class XMLParserCallbacks < Nokogiri::XML::SAX::Document
  def initialize(xml2esf)
    @xml2esf = xml2esf
    @stack = @xml2esf.stack
    @start_context = Hash.new{|ht,k| raise "Unknown tag open #{k}"}.merge({
      # Basic
      :flt         => :on_start_chara_only,
      :byte        => :on_start_chara_only,
      :s           => :on_start_chara_only,
      :asc         => :on_start_chara_only,
      :u           => :on_start_chara_only,
      :i           => :on_start_chara_only,
      :i2          => :on_start_chara_only,
      :u2          => :on_start_chara_only,
      :u2x         => :on_start_chara_only,
      :i4_ary      => :on_start_chara_only,
      :u4_ary      => :on_start_chara_only,
      :flt_ary     => :on_start_chara_only,
      :u2_ary      => :on_start_chara_only,
      :v2_ary      => :on_start_chara_only,
      :v3_ary      => :on_start_chara_only,
      :bin0        => :on_start_chara_only,
      :bin1        => :on_start_chara_only,
      :bin2        => :on_start_chara_only,
      :bin3        => :on_start_chara_only,
      :bin4        => :on_start_chara_only,
      :bin5        => :on_start_chara_only,
      :bin6        => :on_start_chara_only,
      :bin7        => :on_start_chara_only,
      :bin8        => :on_start_chara_only,
      :bin9        => :on_start_chara_only,
      :binA        => :on_start_chara_only,
      :binB        => :on_start_chara_only,
      :binC        => :on_start_chara_only,
      :binD        => :on_start_chara_only,
      :binE        => :on_start_chara_only,
      :binF        => :on_start_chara_only,
      :yes         => :on_start_yes,
      :no          => :on_start_no,
      :esf         => :on_start_esf,
      :ary         => :on_start_ary,
      :rec         => :on_start_rec,
      :node_type   => :on_start_node_type,
      :node_types  => :on_start_node_types,
      :xml_include => :on_start_xml_include,
      :v2          => :on_start_v2,
      :v3          => :on_start_v3,

      ## Semantic
      # rec / startpos.esf
      :date                    => :on_start_chara_only,
      :agent_ability           => :on_start_agent_ability,
      :loc                     => :on_start_chara_only,
      :map                     => :on_start_map,
      :land_key                => :on_start_chara_only,
      :naval_key               => :on_start_chara_only,
      :unit_key                => :on_start_chara_only,
      :traits                  => :on_start_chara_only,
      :agent_attribute_bonuses => :on_start_chara_only,
      :agent_attributes        => :on_start_chara_only,

      # rec / regions.esf
      :climate_map           => :on_start_climate_map,
      :connectivity          => :on_start_connectivity,
      :bounds_block          => :on_start_bounds_block,
      :wind_map              => :on_start_wind_map,
      :black_shroud_outlines => :on_start_black_shroud_outlines,

      # ary / regions.esf
      :groundtype_index      => :on_start_chara_only,
      :land_indices          => :on_start_chara_only,
      :sea_indices           => :on_start_chara_only,
      :region_keys           => :on_start_chara_only,

      # ary / startpos.esf
      :resources_array       => :on_start_chara_only,
      :religion_breakdown    => :on_start_chara_only,
      :REGION_KEYS           => :on_start_chara_only,
      :commodities_order     => :on_start_chara_only,
      :resources_order       => :on_start_chara_only,
      :port_indices          => :on_start_chara_only,
      :settlement_indices    => :on_start_chara_only,
      :region_ownership      => :on_start_chara_only,
      
      # ary / traderoutes.esf
      :settlements           => :on_start_chara_only,
      
      # rec / bmd.dat
      :bmd_textures          => :on_start_bmd_textures,
      :bin6ext               => :on_start_bin6ext,
      :bmd_pgm               => :on_start_bmd_pgm,
      :ground_type_field     => :on_start_ground_type_field,
      :height_field          => :on_start_height_field,
    })
    @end_context = Hash.new{|ht,k| raise "Unknown tag close #{k}"}.merge({
      # Basic
      :flt         => :on_end_flt,
      :byte        => :on_end_byte,
      :s           => :on_end_s,
      :asc         => :on_end_asc,
      :u           => :on_end_u,
      :i           => :on_end_i,
      :i2          => :on_end_i2,
      :u2          => :on_end_u2,
      :u2x         => :on_end_u2x,
      :i4_ary      => :on_end_i4_ary,
      :u4_ary      => :on_end_u4_ary,
      :flt_ary     => :on_end_flt_ary,
      :u2_ary      => :on_end_u2_ary,
      :v2_ary      => :on_end_v2_ary,
      :v3_ary      => :on_end_v3_ary,
      :bin0        => :on_end_bin0,
      :bin1        => :on_end_bin1,
      :bin2        => :on_end_bin2,
      :bin3        => :on_end_bin3,
      :bin4        => :on_end_bin4,
      :bin5        => :on_end_bin5,
      :bin6        => :on_end_bin6,
      :bin7        => :on_end_bin7,
      :bin8        => :on_end_bin8,
      :bin9        => :on_end_bin9,
      :binA        => :on_end_binA,
      :binB        => :on_end_binB,
      :binC        => :on_end_binC,
      :binD        => :on_end_binD,
      :binE        => :on_end_binE,
      :binF        => :on_end_binF,
      :yes         => :on_end_ignore,
      :no          => :on_end_ignore,
      :esf         => :on_end_esf,
      :ary         => :on_end_ary,
      :rec         => :on_end_rec,
      :node_type   => :on_end_ignore,
      :node_types  => :on_end_ignore,
      :xml_include => :on_end_ignore,
      :v2          => :on_end_ignore,
      :v3          => :on_end_ignore,

      ## Semantic
      # rec / startpos.esf
      :date                    => :on_end_date,
      :agent_ability           => :on_end_ignore,
      :loc                     => :on_end_loc,
      :map                     => :on_end_ignore,
      :land_key                => :on_end_land_key,
      :naval_key               => :on_end_naval_key,
      :unit_key                => :on_end_unit_key,
      :traits                  => :on_end_traits,
      :agent_attribute_bonuses => :on_end_agent_attribute_bonuses,
      :agent_attributes        => :on_end_agent_attributes,

      # rec / regions.esf
      :climate_map           => :on_end_ignore,
      :connectivity          => :on_end_ignore,
      :bounds_block          => :on_end_ignore,
      :wind_map              => :on_end_ignore,
      :black_shroud_outlines => :on_end_black_shroud_outlines,

      # ary / regions.esf
      :groundtype_index      => :on_end_groundtype_index,
      :land_indices          => :on_end_land_indices,
      :sea_indices           => :on_end_sea_indices,
      :region_keys           => :on_end_region_keys,

      # ary / startpos.esf
      :resources_array       => :on_end_resources_array,
      :religion_breakdown    => :on_end_religion_breakdown,
      :REGION_KEYS           => :on_end_REGION_KEYS,
      :commodities_order     => :on_end_commodities_order,
      :resources_order       => :on_end_resources_order,
      :port_indices          => :on_end_port_indices,
      :settlement_indices    => :on_end_settlement_indices,
      :region_ownership      => :on_end_region_ownership,

      # ary / traderoutes.esf
      :settlements           => :on_end_settlements,
      
      # rec / bmd.dat
      :bmd_textures          => :on_end_rec,
      :bin6ext               => :on_end_ignore,
      :bmd_pgm               => :on_end_ignore,
      :ground_type_field     => :on_end_ignore,
      :height_field          => :on_end_ignore,
    })
    super()
  end
  def start_element(element, attributes)
    raise "Cannot nest tags in this context" unless @xml2esf.stack[-1][:nest]
    attrs = {}
    attrs[attributes.shift.to_sym] = attributes.shift until attributes.empty?
    @stack << @xml2esf.send(@start_context[element.to_sym], attrs)
  end
  def end_element(element)
    @xml2esf.send(@end_context[element.to_sym], @stack.pop)
  end
  def characters(chars)
    if @stack[-1][:buf]
      @stack[-1][:buf] << chars
    elsif chars =~ /\S/
      raise "Illegal place for non-whitespace characters" 
    end
  end
end

module XmlCallbacks 
  ## Utilities
  
  def semantic_put_ary(type, data, n=1)
    on_start_ary :type => type
    until data.empty?
      @esf.start_elem
      yield(*data.shift(n))
      @esf.end_rec
    end
    @esf.end_ary
  end
  
  ## Semantic
  def on_end_loc(ctx)
    on_start_rec :type => "CAMPAIGN_LOCALISATION"
    if ctx[:buf] == ""
      @esf.put_s ""
      @esf.put_s ""
    else
      @esf.put_s ctx[:buf]
    end
    @esf.end_rec
  end
  
  def on_start_bmd_textures(attributes)
    on_start_rec :type => "BMD_TEXTURES"
  end
  
  def on_start_bin6ext(attributes)
    data = File.open(File.join(@in_dir, attributes[:path]), 'rb', &:read)
    @esf.put_4x("\x46", data)
  end
  
  def on_start_bmd_pgm(attributes)
    xsz, ysz, data = File.read_pgm(File.join(@in_dir, attributes[:pgm]))
    @esf.put_u xsz/4
    @esf.put_u ysz
    @esf.put_4x("\x46", data)
  end
  
  def on_start_ground_type_field(attributes)
    xsz, ysz, data = File.read_pgm(File.join(@in_dir, attributes[:pgm]))
    on_start_rec :type => "GROUND_TYPE_FIELD"
    @esf.put_u xsz/4
    @esf.put_u ysz
    @esf.put_v2 attributes[:xsz].to_f, attributes[:ysz].to_f
    @esf.put_4x("\x44", data)
    @esf.end_rec
  end

  def on_start_height_field(attributes)
    xsz, ysz, data = File.read_pgm(File.join(@in_dir, attributes[:pgm]))
    on_start_rec :type => "HEIGHT_FIELD"
    @esf.put_u xsz/4
    @esf.put_u ysz
    @esf.put_v2 attributes[:xsz].to_f, attributes[:ysz].to_f
    @esf.put_4x("\x4a", data)
    @esf.put_i attributes[:unknown].to_i
    @esf.put_flt attributes[:hmin].to_f
    @esf.put_flt attributes[:hmax].to_f
    @esf.end_rec
  end

  def on_end_settlements(ctx)
    semantic_put_ary("SETTLEMENTS", ctx[:buf].strip.split(/\s+/)) do |name|
      @esf.put_s name
    end
  end
  
  def on_end_resources_array(ctx)
    semantic_put_ary("RESOURCES_ARRAY", ctx[:buf].strip.split(/\s+/)) do |name|
      @esf.put_s name
    end
  end
  
  def on_end_REGION_KEYS(ctx)
    semantic_put_ary("REGION_KEYS", ctx[:buf].strip.split(/\s+/)) do |name|
      @esf.put_s name
    end
  end
  
  def on_end_commodities_order(ctx)
    semantic_put_ary("COMMODITIES_ORDER", ctx[:buf].strip.split(/\s+/)) do |name|
      @esf.put_s name
    end
  end
  
  def on_end_resources_order(ctx)
    semantic_put_ary("RESOURCES_ORDER", ctx[:buf].strip.split(/\s+/)) do |name|
      @esf.put_s name
    end
  end
  
  def on_end_port_indices(ctx)
    semantic_put_ary("PORT_INDICES", ctx[:buf].strip.split(/[\s=]+/), 2) do |name, idx|
      @esf.put_s name
      @esf.put_u idx.to_i
    end
  end

  def on_end_traits(ctx)
    on_start_rec :type => "TRAITS"
    semantic_put_ary("TRAIT", ctx[:buf].strip.split(/[\s=]+/), 2) do |trait, level|
      @esf.put_s trait
      @esf.put_i level.to_i
    end
    @esf.end_rec
  end

  def on_end_agent_attribute_bonuses(ctx)
    semantic_put_ary("AgentAttributeBonuses", ctx[:buf].strip.split(/[\s=]+/), 2) do |attr_bonus, level|
      @esf.put_s attr_bonus
      @esf.put_u level.to_i
    end
  end

  def on_end_agent_attributes(ctx)
    semantic_put_ary("AgentAttributes", ctx[:buf].strip.split(/[\s=]+/), 2) do |attribute, level|
      @esf.put_s attribute
      @esf.put_i level.to_i
    end
  end

  
  def on_end_settlement_indices(ctx)
    semantic_put_ary("SETTLEMENT_INDICES", ctx[:buf].strip.split(/[\s=]+/), 2) do |name, idx|
      @esf.put_s name
      @esf.put_u idx.to_i
    end
  end
  
  def on_end_religion_breakdown(ctx)
    semantic_put_ary("RELIGION_BREAKDOWN", ctx[:buf].strip.split(/[\s=]+/), 2) do |religion, percent|
      @esf.put_s religion
      @esf.put_flt percent.to_f
    end
  end
  
  def on_end_region_ownership(ctx)
    semantic_put_ary("REGION_OWNERSHIP", ctx[:buf].strip.split(/[\s=]+/), 2) do |region, owner|
      @esf.put_s region
      @esf.put_s owner
    end
  end

  def on_end_region_keys(ctx)
    semantic_put_ary("region_keys", ctx[:buf].strip.split(/[\s=,]+/), 3) do |region, x, y|
      @esf.put_s region
      @esf.put_v2 x.to_f, y.to_f
    end
  end

  def on_end_sea_indices(ctx)
    semantic_put_ary("sea_indices", ctx[:buf].strip.split(/[\s=]+/), 2) do |name, idx|
      @esf.put_s name
      @esf.put_byte idx.to_i
    end
  end

  def on_end_land_indices(ctx)
    semantic_put_ary("land_indices", ctx[:buf].strip.split(/[\s=]+/), 2) do |name, idx|
      @esf.put_s name
      @esf.put_byte idx.to_i
    end
  end
  
  def on_end_groundtype_index(ctx)
    semantic_put_ary("groundtype_index", ctx[:buf].strip.split(/\s+/)) do |name|
      @esf.put_s name
    end
  end
    
  def on_end_date(ctx)
    on_start_rec :type => "DATE"
    if ctx[:buf] == ""
      @esf.put_u 0
      @esf.put_asc 'summer'
    else
      date_fields = ctx[:buf].strip.split(/\s+/)
      raise "Invalid date: `#{ctx[:buf]}'" unless date_fields.size == 2 and date_fields[1] =~ /\A\d+\z/
      @esf.put_u date_fields[1].to_i
      @esf.put_asc date_fields[0]
    end
    @esf.end_rec
  end
  
  def on_end_land_key(ctx)
    on_start_rec :type => "LAND_RECORD_KEY"
    @esf.put_s ctx[:buf]
    @esf.end_rec
  end

  def on_end_naval_key(ctx)
    on_start_rec :type => "NAVAL_RECORD_KEY"
    @esf.put_s ctx[:buf]
    @esf.end_rec
  end

  def on_end_unit_key(ctx)
    on_start_rec :type => "UNIT_RECORD_KEY"
    @esf.put_s ctx[:buf]
    @esf.end_rec
  end
  
  def on_start_agent_ability(attributes)
    on_start_rec :type => "AgentAbilities"
    @esf.put_s attributes[:ability]
    @esf.put_i attributes[:level].to_i
    @esf.put_s attributes[:attribute]
    @esf.end_rec
  end
  
  def on_start_climate_map(attributes)
    xsz, ysz, data = File.read_pgm(File.join(@in_dir, attributes[:pgm]))
    on_start_rec :type => "climate_map"
    @esf.put_u xsz
    @esf.put_u ysz
    @esf.put_4x("\x46", data)
    @esf.end_rec
  end

  def on_start_wind_map(attributes)
    xsz, ysz, data = File.read_pgm(File.join(@in_dir, attributes[:pgm]))
    on_start_rec :type => "wind_map"
    @esf.put_u xsz/2
    @esf.put_u ysz
    @esf.put_flt attributes[:unknown].to_f
    @esf.put_4x("\x42", data)
    @esf.end_rec
  end
  
  def on_start_connectivity(attributes)
    on_start_rec :type => "connectivity"
    @esf.put_u attributes[:mask].hex
    @esf.put_u attributes[:from].to_i
    @esf.put_u attributes[:to].to_i
    @esf.end_rec
  end
  
  def on_start_black_shroud_outlines(attributes)
    {:buf => "", :name => attributes[:name]}
  end
  
  def on_end_black_shroud_outlines(ctx)
    on_start_rec :type => "black_shroud_outlines"
    @esf.put_s ctx[:name]
    @esf.put_v2_ary ctx[:buf].strip.split(/[\s,]+/).map(&:to_f)
    @esf.end_rec
  end
  
  def on_start_bounds_block(attributes)
    on_start_rec :type => "BOUNDS_BLOCK"
    @esf.put_v2 attributes[:xmin].to_f, attributes[:ymin].to_f
    @esf.put_v2 attributes[:xmax].to_f, attributes[:ymax].to_f
    @esf.end_rec
  end
  
  def on_start_map(attributes)
    xsz, ysz, data = File.read_pgm(File.join(@in_dir, attributes[:pgm]))
    on_start_rec :type => "MAPS"
    @esf.put_s attributes[:name]
    @esf.put_u xsz/4
    @esf.put_u ysz
    @esf.put_i attributes[:unknown].to_i
    @esf.put_4x("\x48", data)
    @esf.end_rec
  end

## Basic
  def on_end_ignore(ctx)
  end

  def on_end_asc(ctx)
    @esf.put_asc ctx[:buf]
  end
  def on_end_s(ctx)
    @esf.put_s ctx[:buf]
  end
  def on_end_u(ctx)
    @esf.put_u ctx[:buf].to_i
  end
  def on_end_i(ctx)
    @esf.put_i ctx[:buf].to_i
  end
  def on_end_u2(ctx)
    @esf.put_u2 ctx[:buf].to_i
  end
  def on_end_i2(ctx)
    @esf.put_i2 ctx[:buf].to_i
  end
  def on_end_u2x(ctx)
    @esf.put_u2x ctx[:buf].to_i
  end
  def on_end_byte(ctx)
    @esf.put_byte ctx[:buf].to_i
  end
  def on_end_esf(ctx)
    @esf.end_esf
  end
  def on_end_flt(ctx)
    @esf.put_flt ctx[:buf].to_f
  end
  def on_end_rec(ctx)
    @esf.end_rec
  end
  def on_end_ary(ctx)
    @esf.end_ary
  end
  def on_end_u4_ary(ctx)
    @esf.put_u4_ary ctx[:buf].strip.split(/\s+/).map(&:to_i)
  end
  def on_end_i4_ary(ctx)
    @esf.put_i4_ary ctx[:buf].strip.split(/\s+/).map(&:to_i)
  end
  def on_end_u2_ary(ctx)
    @esf.put_u2_ary ctx[:buf].strip.split(/\s+/).map(&:to_i)
  end
  def on_end_flt_ary(ctx)
    @esf.put_flt_ary ctx[:buf].strip.split(/\s+/).map(&:to_f)
  end
  def on_end_v2_ary(ctx)
    @esf.put_v2_ary ctx[:buf].strip.split(/[\s,]+/).map(&:to_f)
  end
  def on_end_v3_ary(ctx)
    @esf.put_v3_ary ctx[:buf].strip.split(/[\s,]+/).map(&:to_f)
  end
  def on_end_bin0(ctx)
    @esf.put_4x(0x40, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_bin1(ctx)
    @esf.put_4x(0x41, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_bin2(ctx)
    @esf.put_4x(0x42, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_bin3(ctx)
    @esf.put_4x(0x43, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_bin4(ctx)
    @esf.put_4x(0x44, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_bin5(ctx)
    @esf.put_4x(0x45, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_bin6(ctx)
    @esf.put_4x(0x46, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_bin7(ctx)
    @esf.put_4x(0x47, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_bin8(ctx)
    @esf.put_4x(0x48, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_bin9(ctx)
    @esf.put_4x(0x49, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_binA(ctx)
    @esf.put_4x(0x4A, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_binB(ctx)
    @esf.put_4x(0x4B, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_binC(ctx)
    @esf.put_4x(0x4C, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_binD(ctx)
    @esf.put_4x(0x4D, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_binE(ctx)
    @esf.put_4x(0x4E, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_end_binF(ctx)
    @esf.put_4x(0x4F, ctx[:buf].strip.split(/\s+/).map{|x| x.to_i(16)}.pack("C*"))
  end
  def on_start_chara_only(attrs)
    {:buf => ""}
  end
  def on_start_yes(attrs)
    @esf.put_yes
    {}
  end
  def on_start_no(attributes)
    @esf.put_no
    {}
  end
  def on_start_v2(attributes)
    @esf.put_v2 attributes[:x].to_f, attributes[:y].to_f
    {}
  end
  def on_start_v3(attributes)
    @esf.put_v3 attributes[:x].to_f, attributes[:y].to_f, attributes[:z].to_f
    {}
  end
  def on_start_xml_include(attributes)
    parse_file(attributes[:path])
    {}
  end
  def on_start_node_type(attributes)
    @esf.add_type_code attributes[:name]
    {}
  end
  def on_start_node_types(attributes)
    {:nest => true}
  end
  def on_start_esf(attributes)
    raise "Magic attribute required" unless attributes[:magic]
    @esf.start_esf attributes[:magic].split(/\s+/).map(&:to_i)
    {:nest => true}
  end
  def on_start_rec(attributes)
    if @stack[-1][:ary]
      @esf.start_elem
    else
      @esf.start_rec attributes[:type], attributes[:version]
    end
    {:nest => true}
  end
  def on_start_ary(attributes)
    @esf.start_ary attributes[:type], attributes[:version]
    {:nest => true, :ary => true}
  end
end

class Xml2Esf
  include XmlCallbacks
  attr_reader :esf, :stack
  
  def self.parse(in_dir)
    new(in_dir).esf.data
  end

  def parse_file(rel_path)
    parser = Nokogiri::XML::SAX::Parser.new(@callbacks, 'UTF-8')
    parser.parse_file(File.join(@in_dir, rel_path))
  end

  def initialize(in_dir)
    @in_dir = in_dir
    @esf    = EsfBuilder.new
    @stack  = [{:nest => true}]
    @callbacks = XMLParserCallbacks.new(self)
    parse_file('esf.xml')
  end
end

unless ARGV.size == 2
  STDERR.puts "Usage: #{$0} input_dir output.esf"
  exit 1
end

in_dir = ARGV[0]
out_file = File.open(ARGV[1], 'wb')

out_file.write Xml2Esf.parse(in_dir)
