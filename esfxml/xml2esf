#!/usr/bin/env ruby

require 'rubygems'
require "nokogiri"
require "esf_builder"
require "pp"

class XMLParserCallbacks < Nokogiri::XML::SAX::Document
  def initialize(xml2esf)
    @xml2esf = xml2esf
    super()
  end
  def start_element(element, attributes)
    attrs = {}
    until attributes.empty?
      attrs[attributes.shift.to_sym] = attributes.shift
    end
    @xml2esf.on_start_element(element.to_sym, attrs)
  end
  def end_element(element)
    @xml2esf.on_end_element(element.to_sym)
  end
  def characters(chara)
    @xml2esf.on_characters(chara)
  end
end

class Xml2Esf
  attr_reader :esf
    
  def self.parse(in_dir)
    new(in_dir).esf.data
  end

  def parse_file(rel_path)
    parser = Nokogiri::XML::SAX::Parser.new(@callbacks, 'UTF-8')
    parser.parse_file(File.join(@in_dir, rel_path))
  end

  def initialize(in_dir)
    @in_dir = in_dir
    @esf    = EsfBuilder.new
    @stack  = [{:chara => false, :nest => true}]
    @callbacks = XMLParserCallbacks.new(self)
    parse_file('esf.xml')
  end

  EndOnly = {
    :flt     => true,
    :byte    => true,
    :s       => true,
    :asc     => true,
    :u       => true,
    :i       => true,
    :i2      => true,
    :u2      => true,
    :u2x     => true,
    :i4_ary  => true,
    :flt_ary => true,
    :u2_ary  => true,
    :v2_ary  => true,
    :v3_ary  => true,
    :bin0    => true,
    :bin1    => true,
    :bin2    => true,
    :bin3    => true,
    :bin4    => true,
    :bin5    => true,
    :bin6    => true,
    :bin7    => true,
    :bin8    => true,
    :bin9    => true,
    :binA    => true,
    :binB    => true,
    :binC    => true,
    :binD    => true,
    :binE    => true,
    :binF    => true,
  }

  def on_start_element(element, attributes)
    raise "Illegal place for nested element: #{@stack[-1].inspect}" unless @stack[-1][:nest]
    
    finalization = {}
    chara_ok = false
    nest_ok = false
    el = element.to_sym
     
    if EndOnly[el]
      chara_ok = true
    else
      case el
      when :yes
        @esf.put_yes
      when :no
        @esf.put_no
      when :v2
        @esf.put_v2 attributes[:x].to_f, attributes[:y].to_f
      when :v3
        @esf.put_v3 attributes[:x].to_f, attributes[:y].to_f, attributes[:z].to_f
      when :rec
        if @stack[-1][:el] == :ary
          @esf.start_elem
        else
          @esf.start_rec attributes[:type], attributes[:version]
        end
        nest_ok = true
      when :ary
        @esf.start_ary attributes[:type], attributes[:version]
        nest_ok = true

      when :"xml-include"
        parse_file(attributes[:path])

      when :node_type
        name = attributes[:name]
        @esf.add_type_code attributes[:name]

      when :node_types
        nest_ok = true

      when :esf
        raise "Magic attribute required" unless attributes[:magic]
        @esf.start_esf attributes[:magic].split(/\s+/).map(&:to_i)
        nest_ok = true

      else
        raise "No idea what to do with #{element} open means"
      end
    end

    @stack << {:el => el, :chara => chara_ok, :buf => "", :nest => nest_ok}.merge(finalization)
  end
  
  def on_end_element(element)
    ctx = @stack.pop
    no_finalization = [:node_types, :node_type, :yes, :no, :v2, :v3, :"xml-include"]
    return if no_finalization.include?(element)
    
    case element
    when :asc
      @esf.put_asc ctx[:buf]
    when :s
      @esf.put_s ctx[:buf]
    when :u
      @esf.put_u ctx[:buf].to_i
    when :i
      @esf.put_i ctx[:buf].to_i
    when :u2
      @esf.put_u2 ctx[:buf].to_i
    when :i2
      @esf.put_i2 ctx[:buf].to_i
    when :u2x
      @esf.put_u2x ctx[:buf].to_i
    when :byte
      @esf.put_byte ctx[:buf].to_i
    when :flt
      @esf.put_flt ctx[:buf].to_f
    when :rec
      @esf.end_rec
    when :ary
      @esf.end_ary
    when :u4_ary
      @esf.put_u4_ary ctx[:buf].split.map(&:to_i)
    when :i4_ary
      @esf.put_i4_ary ctx[:buf].split.map(&:to_i)
    when :u2_ary
      @esf.put_u2_ary ctx[:buf].split.map(&:to_i)
    when :flt_ary
      @esf.put_flt_ary ctx[:buf].split.map(&:to_f)
    when :v2_ary
      @esf.put_v2_ary ctx[:buf].split.map(&:to_f)
    when :v3_ary
      @esf.put_v3_ary ctx[:buf].split.map(&:to_f)
    when :bin0, :bin1, :bin2, :bin3, :bin4, :bin5, :bin6, :bin7,
         :bin8, :bin9, :binA, :binB, :binC, :binD, :binE, :binF
      @esf.put_4x(
        [0x40 + element.to_s[-1,1].hex].pack("C"),
        ctx[:buf].split.map{|x| x.to_i(16)}.pack("C*")
      )
    when :esf
      @esf.end_esf
    else
      raise "No idea what to do with #{element} close"
    end
  end
  
  def on_characters(chars)
    if @stack[-1][:chara]
      @stack[-1][:buf] << chars
    else
      raise "Illegal place for non-whitespace characters: #{@stack[-1].inspect}" if chars =~ /\S/
    end
  end
end

unless ARGV.size == 2
  STDERR.puts "Usage: #{$0} input_dir output.esf"
  exit 1
end

in_dir = ARGV[0]
out_file = File.open(ARGV[1], 'wb')

out_file.write Xml2Esf.parse(in_dir)
