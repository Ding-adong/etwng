#!/usr/bin/env ruby

require 'rubygems'
require 'libxml'
require "esf_builder"

include LibXML

class Xml2Esf
  include XML::SaxParser::Callbacks
  attr_reader :esf, :stack, :parser
  
  def self.parse_io(xml_in)
    new(xml_in).esf.data
  end

  def initialize(xml_in)
    @esf = EsfBuilder.new
    @default_version = Hash.new(0)
    @node_types = nil
    @lookup = Hash.new{|ht,k| raise "Unknown node name #{k}"}
    @stack = [{:chara => false, :nest => true}]
    @parser = XML::SaxParser.io(xml_in)
    @parser.callbacks = self
    @parser.parse
  end

  def type_and_version(attributes)
    type_str     = attributes['type']
    type_code    = @lookup[type_str]
    version_str  = attributes['version']
    version = version_str ? version_str.to_i : @default_version[type_str]
    [type_code, version]
  end

  def on_start_element(element, attributes)
    raise "Illegal place for nested element: #{@stack[-1].inspect}" unless @stack[-1][:nest]
    
    finalization = {}
    chara_ok = false
    nest_ok = false
    
    case el = element.to_sym
    when :yes
      @esf.put_yes
    when :no
      @esf.put_no
    when :"v2"
      @esf.put_v2 attributes["x"].to_f, attributes["y"].to_f
    when :"v3"
      @esf.put_v3 attributes["x"].to_f, attributes["y"].to_f, attributes["z"].to_f
    when :rec
      if @stack[-1][:el] == :ary
        @esf.start_elem
      else
        @esf.start_rec *type_and_version(attributes)
      end
      nest_ok = true
    when :ary
      @esf.start_ary *type_and_version(attributes)
      nest_ok = true
    when :flt, :byte, :s, :asc, :u, :i, :i2, :u2, :u2x, :i4_ary,
         :flt_ary, :u2_ary, :v2_ary, :v3_ary,
         :bin0, :bin1, :bin2, :bin3, :bin4, :bin5, :bin6, :bin7,
         :bin8, :bin9, :binA, :binB, :binC, :binD, :binE, :binF
      chara_ok = true

    when :esf
      @esf.start_esf attributes["magic"].split(/\s+/).map(&:to_i)
      nest_ok = true

    when :node_types
      @node_types = []
      nest_ok = true

    when :node_type
      name = attributes["name"]
      raise "Name already set: #{name}" if @lookup.has_key?(name)
      @lookup[name] = @node_types.size
      @node_types << name

    else
      raise "No idea what to do with #{element} open means"
    end

    @stack << {:el => el, :chara => chara_ok, :buf => "", :nest => nest_ok}.merge(finalization)
  end
  
  def on_end_element(element)
    ctx = @stack.pop
    el = element.to_sym
    no_finalization = [:node_types, :node_type, :yes, :no, :v2, :v3]
    return if no_finalization.include?(el)
    
    case el
    when :asc
      @esf.put_asc ctx[:buf]
    when :s
      @esf.put_s ctx[:buf]
    when :u
      @esf.put_u ctx[:buf].to_i
    when :i
      @esf.put_i ctx[:buf].to_i
    when :u2
      @esf.put_u2 ctx[:buf].to_i
    when :i2
      @esf.put_i2 ctx[:buf].to_i
    when :u2x
      @esf.put_u2x ctx[:buf].to_i
    when :byte
      @esf.put_byte ctx[:buf].to_i
    when :flt
      @esf.put_flt ctx[:buf].to_f
    when :rec
      @esf.end_rec
    when :ary
      @esf.end_ary
    when :u4_ary
      @esf.put_u4_ary ctx[:buf].split.map(&:to_i)
    when :i4_ary
      @esf.put_i4_ary ctx[:buf].split.map(&:to_i)
    when :u2_ary
      @esf.put_u2_ary ctx[:buf].split.map(&:to_i)
    when :flt_ary
      @esf.put_flt_ary ctx[:buf].split.map(&:to_f)
    when :v2_ary
      @esf.put_v2_ary ctx[:buf].split.map(&:to_f)
    when :v3_ary
      @esf.put_v3_ary ctx[:buf].split.map(&:to_f)
    when :bin0, :bin1, :bin2, :bin3, :bin4, :bin5, :bin6, :bin7,
         :bin8, :bin9, :binA, :binB, :binC, :binD, :binE, :binF
      @esf.put_4x(
        [0x40 + element[-1,1].hex].pack("C"),
        ctx[:buf].split.map{|x| x.to_i(16)}.pack("C*")
      )
    when :esf
      @esf.put_node_types_table @node_types
    else
      raise "No idea what to do with #{element} close"
    end
  end
  
  def on_characters(chars)
    if @stack[-1][:chara]
      @stack[-1][:buf] << chars
    else
      raise "Illegal place for non-whitespace characters: #{@stack[-1].inspect}" if chars =~ /\S/
    end
  end
end

unless ARGV.size == 2
  STDERR.puts "Usage: #{$0} input.xml output.esf"
  exit 1
end

in_file = File.open(ARGV[0], 'rb')
out_file = File.open(ARGV[1], 'wb')

out_file.write Xml2Esf.parse_io(in_file)
