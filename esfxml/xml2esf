#!/usr/bin/env ruby

require 'rubygems'
require 'libxml'

class EsfBuilder
  attr_reader :data
  def initialize
    @data = ""
  end
  def adjust_ofs(at)
    @data[at, 4] = [@data.size].pack("V")
  end
  def put(bytes)
    @data << bytes
  end
  def put_yes
    @data << "\x01\x01"
  end
  def put_no
    @data << "\x01\x00"
  end
  def put_v2(x,y)
    @data << [0x0c, x, y].pack("Cff")
  end
  def put_v3(x,y,z)
    @data << [0x0d, x, y, z].pack("Cfff")
  end
  def put_byte(val)
    @data << "\x06"
    @data << [val].pack("C")
  end
  def put_flt(val)
    @data << "\x0a"
    @data << [val].pack("f")
  end
  def put_i2(val)
    @data << "\x00"
    @data << [val].pack("v")
  end
  def put_u2(val)
    @data << "\x07"
    @data << [val].pack("v")
  end
  def put_u2x(val)
    @data << "\x10"
    @data << [val].pack("v")
  end
  def put_i(val)
    @data << "\x04"
    @data << [val].pack("V")
  end
  def put_u(val)
    @data << "\x08"
    @data << [val].pack("V")
  end
  def put_s(str)
    @data << "\x0e"
    uchars = str.unpack("U*")
    @data << [uchars.size, *uchars].pack("v*")
  end
  def put_asc(str)
    @data << "\x0f"
    @data << [str.size].pack("v")
    @data << str
  end
  def put_4x(code, ary_data)
    @data << code
    @data << [@data.size + 4 + ary_data.size].pack("V")
    @data << ary_data
  end

  def put_u4_ary(elems)
    put_4x("\x44", elems.pack("V*"))
  end
  def put_i4_ary(elems)
    put_4x("\x48", elems.pack("V*"))
  end
  def put_i2_ary(elems)
    put_4x("\x40", elems.pack("v*"))
  end
  def put_u2_ary(elems)
    put_4x("\x47", elems.pack("v*"))
  end
  def put_flt_ary(elems)
    put_4x("\x4a", elems.pack("f*"))
  end
  def put_v2_ary(elems) # Contrary to name, it contains floats
    put_4x("\x4c", elems.pack("f*"))
  end
  def put_v3_ary(elems) # Contrary to name, it contains floats
    put_4x("\x4d", elems.pack("f*"))
  end
end

# TODO: First, this class must totally forget anything about low-level Esf serialization,
#       only using @esf for such things

include LibXML

class Xml2Esf
  include XML::SaxParser::Callbacks
  attr_reader :esf, :stack, :parser
  
  def self.parse_io(xml_in)
    new(xml_in).esf.data
  end

  def initialize(xml_in)
    @esf = EsfBuilder.new

    @node_types = nil
    @lookup = Hash.new{|ht,k| raise "Unknown node name #{k}"}
    @stack = [{:chara => false, :nest => true}]

    @parser = XML::SaxParser.io(xml_in)
    @parser.callbacks = self
    @parser.parse
  end

  def on_start_element(element, attributes)
    raise "Illegal place for nested element: #{@stack[-1].inspect}" unless @stack[-1][:nest]
    
    ofs = @esf.data.size
    finalization = {}
    chara_ok = false
    nest_ok = false
    
    case el = element.to_sym
    when :yes
      @esf.put_yes
    when :no
      @esf.put_no
    when :"v2"
      @esf.put_v2 attributes["x"].to_f, attributes["y"].to_f
    when :"v3"
      @esf.put_v3 attributes["x"].to_f, attributes["y"].to_f, attributes["z"].to_f

    when :flt, :byte, :s, :asc, :u, :i, :i2, :u2, :u2x, :i4_ary,
         :flt_ary, :u2_ary, :v2_ary, :v3_ary,
         :bin0, :bin1, :bin2, :bin3, :bin4, :bin5, :bin6, :bin7,
         :bin8, :bin9, :binA, :binB, :binC, :binD, :binE, :binF
      chara_ok = true

    when :rec
      if @stack[-1][:el] == :ary
        @stack[-1][:children] += 1
        @esf.put "\x00\x00\x00\x00"
      else
        finalization = {:ofs => ofs + 4}
        name_code = @lookup[attributes['type']]
        version = attributes['version'].to_i
        @esf.put([0x80, name_code, version, 0].pack("CvCV"))
      end
      nest_ok = true

    when :ary
      name_code = @lookup[attributes['type']]
      version = attributes['version'].to_i
      @esf.put([0x81, name_code, version, 0, 0].pack("CvCVV"))
      finalization = {:children => 0}
      nest_ok = true

    when :esf
      @magic = attributes["magic"].split(/\s+/).map{|x| x.to_i}
      @esf.put(@magic.pack("V*"))
      finalization[:end_of_headers] = @esf.data.size
      @esf.put([0].pack("V"))
      nest_ok = true

    when :node_types
      @node_types = []
      nest_ok = true

    when :node_type
      name = attributes["name"]
      raise "Name already set: #{name}" if @lookup.has_key?(name)
      @lookup[name] = @node_types.size
      @node_types << name

    else
      raise "No idea what to do with #{element} open means"
    end

    @stack << {:el => el, :ofs => ofs, :chara => chara_ok, :buf => "", :nest => nest_ok}.merge(finalization)
  end
  
  def on_end_element(element)
    ctx = @stack.pop
    el = element.to_sym
    no_finalization = [:node_types, :node_type, :yes, :no, :v2, :v3]
    return if no_finalization.include?(el)
    
    case el
    when :asc
      @esf.put_asc ctx[:buf]
    when :s
      @esf.put_s ctx[:buf]
    when :u
      @esf.put_u ctx[:buf].to_i
    when :i
      @esf.put_i ctx[:buf].to_i
    when :u2
      @esf.put_u2 ctx[:buf].to_i
    when :i2
      @esf.put_i2 ctx[:buf].to_i
    when :u2x
      @esf.put_u2x ctx[:buf].to_i
    when :byte
      @esf.put_byte ctx[:buf].to_i
    when :flt
      @esf.put_flt ctx[:buf].to_f
    when :rec
      @esf.adjust_ofs(ctx[:ofs])
    when :ary
      @esf.data[ctx[:ofs]+4, 8] = [@esf.data.size, ctx[:children]].pack("VV")
    when :u4_ary
      @esf.put_u4_ary ctx[:buf].split.map(&:to_i)
    when :i4_ary
      @esf.put_i4_ary ctx[:buf].split.map(&:to_i)
    when :u2_ary
      @esf.put_u2_ary ctx[:buf].split.map(&:to_i)
    when :flt_ary
      @esf.put_flt_ary ctx[:buf].split.map(&:to_f)
    when :v2_ary
      @esf.put_v2_ary ctx[:buf].split.map(&:to_f)
    when :v3_ary
      @esf.put_v3_ary ctx[:buf].split.map(&:to_f)
    when :bin0, :bin1, :bin2, :bin3, :bin4, :bin5, :bin6, :bin7,
         :bin8, :bin9, :binA, :binB, :binC, :binD, :binE, :binF
      @esf.put_4x(
        [0x40 + element[-1,1].hex].pack("C"),
        ctx[:buf].split.map{|x| x.to_i(16)}.pack("C*")
      )
    when :esf
      @esf.adjust_ofs(ctx[:end_of_headers])
      @esf.put([@node_types.size].pack("v"))
      @node_types.each{|nn|
        @esf.put([nn.size].pack("v"))
        @esf.put(nn)
      }
    else
      raise "No idea what to do with #{element} close"
    end
  end
  
  def on_characters(chars)
    if @stack[-1][:chara]
      @stack[-1][:buf] << chars
    else
      raise "Illegal place for non-whitespace characters: #{@stack[-1].inspect}" if chars =~ /\S/
    end
  end
end

STDOUT.write Xml2Esf.parse_io(STDIN)
