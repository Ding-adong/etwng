#!/usr/bin/env ruby

require "pp"

class String
  # Escape string for output as XML text (< > &)
  def xml_escape
    replacements = {"<" => "&lt;", ">" => "&gt;", "&" => "&amp;" }
    gsub(/([<>&])/) { replacements[$1] }
  end
  # Escape characters for output as XML attribute values (< > & ' ")
  def xml_attr_escape
    replacements = {"<" => "&lt;", ">" => "&gt;", "&" => "&amp;", "\"" => "&quot;", "'" => "&apos;"}
    gsub(/([<>&\'\"])/) { replacements[$1] }
  end
  def to_hex_dump
    unpack("H2" * size).join(" ")
  end
  def to_flt_dump
    unpack("f*").join(" ")
  end
end

module EsfBasicBinaryOps
  def get_u4
    rv = @data[@ofs,4].unpack("V")[0]
    @ofs += 4
    rv
  end
  def get_i4
    rv = @data[@ofs,4].unpack("l")[0]
    @ofs += 4
    rv
  end
  def get_i2
    rv = @data[@ofs,2].unpack("s")[0]
    @ofs += 2
    rv
  end
  def get_float
    rv = @data[@ofs,4].unpack("f")[0]
    @ofs += 4
    rv
  end
  def get_u2
    rv = @data[@ofs,2].unpack("v")[0]
    @ofs += 2
    rv
  end
  def get_bytes(sz)
    rv = @data[@ofs, sz]
    @ofs += sz
    rv
  end
  def get_ascii
    get_bytes(get_u2)
  end
  def get_str
    get_bytes(get_u2*2).unpack("v*").pack("U*")
  end
  def get_byte
    rv = @data[@ofs]
    @ofs += 1
    rv
  end
  def get_bool
    case b = get_byte
    when 1
      true
    when 0
      false
    else
      warn "Weird boolean value: #{b}"
      true
    end
  end    
  def with_temp_ofs(tmp)
    orig = @ofs
    begin
      @ofs = tmp
      yield
    ensure
      @ofs = orig
    end
  end
  def size
    @data.size
  end
end

class EsfParser
  include EsfBasicBinaryOps
  
  attr_accessor :ofs
  attr_reader :data, :out, :done
  attr_reader :magic, :node_types

  def initialize(in_fh, out_fh)
    @data = in_fh.read
    @xmlout = XMLPrinter.new(out_fh)
    @ofs = 0
    get_header
    @esf_type_handlers = setup_esf_type_handlers
    @default_version = Hash.new(0)
  end
  def setup_esf_type_handlers
    out = Hash.new{|ht,node_type|
      raise "Unknown type 0x%02x at %d" % [node_type, ofs]
    }
    (0..255).each{|i|
      name = ("convert_%02x!" % i).to_sym
      out[i] = name if respond_to?(name)
    }
    out
  end
  def get_header
    case magic = get_u4
    when 0xABCD
      @magic = [0xABCD]
    when 0xABCE
      a = get_u4
      b = get_u4
      raise "Incorrect ESF magic followup" unless a == 0
      @magic = [0xABCE, a, b]
    else
      raise "Incorrect ESF magic: %X" % magic
    end
    with_temp_ofs(get_u4) {
      @node_types = get_node_types
    }
  end
  def get_node_types
    (0...get_u2()).map{ get_ascii.to_sym }
  end
  def inspect
    "EsfParser(#{@ofs})"
  end
  def get_node_type
    @node_types[get_u2]
  end
  def convert_until_ofs!(ofs_end)
    convert_value! while @ofs < ofs_end
  end
  def convert_00!
    @xmlout.out!("<i2>#{get_i2}</i2>")
  end
  def convert_01!
    @xmlout.out!(get_bool ? "<yes/>" : "<no/>")
  end
  def convert_04!
    @xmlout.out!("<i>#{get_i4}</i>")
  end
  def convert_06!
    @xmlout.out!("<byte>#{get_byte}</byte>")
  end
  def convert_07!
    @xmlout.out!("<u2>#{get_u2}</u2>")
  end
  def convert_08!
    @xmlout.out!("<u>#{get_u4}</u>")
  end
  def convert_0a!
    @xmlout.out!("<flt>#{get_float}</flt>")
  end
  def convert_0c!
    @xmlout.out!("<v2 x='#{get_float}' y='#{get_float}'/>")
  end
  def convert_0d!
    @xmlout.out!("<v3 x='#{get_float}' y='#{get_float}' z='#{get_float}'/>")
  end
  def convert_0e!
    @xmlout.out!("<s>#{get_str.xml_escape}</s>")
  end
  def convert_0f!
    @xmlout.out!("<asc>#{get_ascii.xml_escape}</asc>")
  end
  def convert_10!
    @xmlout.out!("<u2x>#{get_u2}</u2x>")
  end
  def convert_40!
    @xmlout.out!("<bin0>#{get_ofs_bytes.to_hex_dump}</bin0>")
  end
  def convert_41!
    @xmlout.out!("<bin1>#{get_ofs_bytes.to_hex_dump}</bin1>")
  end
  def convert_42!
    @xmlout.out!("<bin2>#{get_ofs_bytes.to_hex_dump}</bin2>")
  end
  def convert_43!
    @xmlout.out!("<bin3>#{get_ofs_bytes.to_hex_dump}</bin3>")
  end
  def convert_44!
    @xmlout.out!("<bin4>#{get_ofs_bytes.to_hex_dump}</bin4>")
  end
  def convert_45!
    @xmlout.out!("<bin5>#{get_ofs_bytes.to_hex_dump}</bin5>")
  end
  def convert_46!
    @xmlout.out!("<bin6>#{get_ofs_bytes.to_hex_dump}</bin6>")
  end
  def convert_47!
    @xmlout.out!("<u2_ary>#{get_ofs_bytes.unpack("v*").join(" ")}</u2_ary>")
  end
  def convert_48!
    @xmlout.out!("<i4_ary>#{get_ofs_bytes.unpack("l*").join(" ")}</i4_ary>")
  end
  def convert_49!
    @xmlout.out!("<bin9>#{get_ofs_bytes.to_hex_dump}</bin9>")
  end
  def convert_4a!
    @xmlout.out!("<flt_ary>#{get_ofs_bytes.to_flt_dump}</flt_ary>")
  end
  def convert_4b!
    @xmlout.out!("<binB>#{get_ofs_bytes.to_hex_dump}</binB>")
  end
  def convert_4c!
    @xmlout.out!("<v2_ary>#{get_ofs_bytes.to_flt_dump}</v2_ary>")
  end
  def convert_4d!
    @xmlout.out!("<v3_ary>#{get_ofs_bytes.to_flt_dump}</v3_ary>")
  end
  def convert_4e!
    @xmlout.out!("<binE>#{get_ofs_bytes.to_hex_dump}</binE>")
  end
  def convert_4f!
    @xmlout.out!("<binF>#{get_ofs_bytes.to_hex_dump}</binF>")
  end
  def convert_80!
    node_type   = get_node_type
    version     = get_byte
    ofs_end     = get_u4
    version   = nil if version == @default_version[node_type]
    @xmlout.tag!("rec", :type=>node_type, :version=>version) do
      convert_until_ofs!(ofs_end)
    end
  end
  def convert_81!
    node_type = get_node_type
    version   = get_byte
    ofs_end   = get_u4
    count     = get_u4
    version   = nil if version == @default_version[node_type]
    @xmlout.tag!("ary", :type=>node_type, :version=>version) do
      count.times do
        @xmlout.tag!("rec", :type=>node_type) do
          convert_until_ofs!(get_u4)
        end
      end
    end
  end
  def convert_value!
    send(@esf_type_handlers[get_byte])
  end
  def get_ofs_bytes
    ofs_end = get_u4
    sz = ofs_end-@ofs
    get_bytes(sz)
  end
  def context
    "#{@ofs} [ #{@data[@ofs, 32].unpack("C*").join(" ")}]"
  end
  def convert!
    @done = false
    @xmlout.tag!("esf", :magic => @magic.join(" ")) do
      @xmlout.tag!("node_types") do
        node_types.each do |n|
          @xmlout.tag!("node_type", :name => n)
        end
      end
      convert_value!
    end
    @xmlout.flush
    @done = true
  end
  def progressbar_thread
    Thread.new{
      begin
        puts "Done: %0.1f%%" % (100.0 * @ofs.to_f / @data.size)
        5.times {
          sleep 1
          break if @done
        }
      end until @done
    }
  end
end

class XMLPrinter
  attr_reader :out_buf
  def initialize(out_fh)
    @out_fh  = out_fh
    @out_buf = ""
    @stack = []
    @indent = Hash.new{|ht,k| ht[k]=" "*k}
  end
  def flush
    @out_fh.write @out_buf
    @out_buf = ""
  end
  def tag!(name, *args)
    raise ArgumentError.new("Too many arguments") if args.size > 2
    
    attrs_s = ""
    cnt = nil

    if args.size == 2
      attrs_s = attrs_to_s(args[0])
      cnt = args[1]
    elsif args.size == 1
      if args[0].is_a?(Hash)
        attrs_s = attrs_to_s(args[0])
      else
        cnt = args[0]
      end
    end
    
    cnt = nil if cnt == ""

    if block_given?
      raise ArgumentError.new("Cannot use content argument and bolck at the same time") if cnt
      out! "<#{name}#{attrs_s}>"
      @stack << name
      yield
      @stack.pop
      out! "</#{name}>"
    elsif cnt.nil?
      out! "<#{name}#{attrs_s}/>"
    else
      out! "<#{name}#{attrs_s}>#{cnt}</#{name}>"
    end
  end
  def out!(str)
    @out_buf << @indent[@stack.size] << str << "\n"
    flush if @out_buf.size > 1_000_000
  end
  private
  def attrs_to_s(attrs={})
    attrs.to_a.map{|k,v| v.nil? ? "" : " #{k}='#{v.to_s.xml_attr_escape}'"}.join
  end
end

verbose = true
if ARGV[0] == "--quiet"
  ARGV.shift
  verbose = false
end

unless ARGV.size == 2
  STDERR.puts <<EOF
Usage:
  #{$0} input.esf output.xml
To hide progress bar:
  #{$0} --quiet input.esf output.xml
EOF
  exit 1
end

in_file = File.open(ARGV[0], 'rb')
out_file = File.open(ARGV[1], 'wb')

esf = EsfParser.new(in_file, out_file)
thr = esf.progressbar_thread if verbose
esf.convert!
