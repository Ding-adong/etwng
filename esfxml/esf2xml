#!/usr/bin/env ruby

require "default_versions"
require "fileutils"
require "pp"
require "esf_parser"
require "pgm"

class Float
  def pretty_single
    rv = (((100_000.0 * self).round / 100_000.0) rescue self)
    return rv if [self].pack("f") == [rv].pack("f")
    self
  end
end

class String
  # Escape string for output as XML text (< > &)
  def xml_escape
    replacements = {"<" => "&lt;", ">" => "&gt;", "&" => "&amp;" }
    gsub(/([<>&])/) { replacements[$1] }
  end
  # Escape characters for output as XML attribute values (< > & ' ")
  def xml_attr_escape
    replacements = {"<" => "&lt;", ">" => "&gt;", "&" => "&amp;", "\"" => "&quot;", "'" => "&apos;"}
    gsub(/([<>&\'\"])/) { replacements[$1] }
  end
  def to_hex_dump
    unpack("H2" * size).join(" ")
  end
  def to_flt_dump
    unpack("f*").join(" ")
  end
  def to_v2_dump
    out = []
    data = unpack("f*")
    out << "#{data.shift},#{data.shift}" until data.empty?
    out.join(" ")
  end
  def to_v3_dump
    out = []
    data = unpack("f*")
    out << "#{data.shift},#{data.shift},#{data.shift}" until data.empty?
    out.join(" ")
  end
end

module EsfParserDebug
  def progressbar_thread
    Thread.new{
      begin
        puts "Done: %0.1f%%" % (100.0 * @ofs.to_f / @data.size)
        5.times {
          sleep 1
          break if @done
        }
      end until @done
    }
  end
end

class SemanticFail < Exception
  attr_reader :save_ofs
  def initialize(save_ofs)
    @save_ofs = save_ofs
    super()
  end
end

module EsfSemantic
  ConvertSemanticRec = {
    :DATE             => :convert_date,
    :AgentAbilities   => :convert_agent_abilities,
    :AgentAttributes  => :convert_agent_attributes,
    :climate_map      => :convert_climate_map,
    :connectivity     => :convert_connectivity,
    :BOUNDS_BLOCK     => :convert_bounds_block,
  }
  def get_rec_contents(exn, *expect_types)
    out     = []
    end_ofs = get_u4
    while @ofs < end_ofs
      t, *v = send(@esf_type_handlers_get[get_byte])
      raise exn unless t == expect_types.shift
      out.push *v
    end
    out
  end
  def convert_bounds_block
    exn = SemanticFail.new(@ofs)
    xmin, ymin, xmax, ymax = get_rec_contents(exn, :v2, :v2)
    @xmlout.out!("<bounds_block xmin='#{xmin}' ymin='#{ymin}' xmax='#{xmax}' ymax='#{ymax}'/>")
  end
  def convert_connectivity
    exn = SemanticFail.new(@ofs)
    mask, cfrom, cto = get_rec_contents(exn, :u4, :u4, :u4)
    @xmlout.out!("<connectivity mask='#{"%08x" % mask}' from='#{cfrom}' to='#{cto}'/>")
  end
  def convert_climate_map
    exn = SemanticFail.new(@ofs)
    xsz, ysz, data = get_rec_contents(exn, :u4, :u4, :bin6)
    path, rel_path = alloc_new_path("climate_map", ".pgm")
    File.write_pgm(path, xsz, ysz, data)
    @xmlout.out!("<climate_map pgm='#{rel_path}'/>")
  end
  def convert_agent_attributes
    exn = SemanticFail.new(@ofs)
    attribute, level = get_rec_contents(exn, :s, :i4)
    @xmlout.out!("<agent_attribute attribute='#{attribute.xml_escape}' level='#{level}'/>")
  end
  def convert_agent_abilities
    exn = SemanticFail.new(@ofs)
    ability, level, attribute = get_rec_contents(exn, :s, :i4, :s)
    @xmlout.out!("<agent_ability ability='#{ability.xml_escape}' level='#{level}' attribute='#{attribute.xml_escape}'/>")
  end
  def convert_date
    exn = SemanticFail.new(@ofs)
    year, season = get_rec_contents(exn, :u4, :asc)
    raise exn if season =~ /\s/
    @xmlout.out!("<date>#{season.xml_escape} #{year}</date>")
  end
end

class EsfParser
  include EsfBasicBinaryOps
  include EsfDefaultConvert
  include EsfParserDebug
  include EsfGetData
  include EsfSemantic
  
  attr_accessor :ofs
  attr_reader :data, :out_dir, :done
  attr_reader :magic, :node_types

  def alloc_new_path(name, ext=".xml")
    file_num = 1
    while true
      if name =~ /\/\z/
        rel_path = "%s%04d%s" % [name, file_num, ext]
      else
        rel_path = "%s-%04d%s" % [name, file_num, ext]
      end
      path     = File.join(out_dir, rel_path)
      FileUtils.mkdir_p File.dirname(path)
      return [path, rel_path] unless File.exist?(path)
      file_num += 1
    end
  end

  def open_xml(name)
    return XMLPrinter.new(*alloc_new_path(name, ".xml"))
  end

  def initialize(in_fh, out_dir)
    @data    = in_fh.read
    @out_dir = out_dir
    @xmlout  = XMLPrinter.new(File.join(out_dir, 'esf.xml'), 'esf.xml')
    @ofs     = 0
    get_header
    @esf_type_handlers = setup_esf_type_handlers
    @esf_type_handlers_get = setup_esf_type_handlers_get
  end

  def setup_esf_type_handlers
    out = Hash.new{|ht,node_type| raise "Unknown type 0x%02x at %d" % [node_type, ofs] }
    (0..255).each{|i|
      name = ("convert_%02x!" % i).to_sym
      out[i] = name if respond_to?(name)
    }
    out
  end
  def setup_esf_type_handlers_get
    out = Hash.new{|ht,node_type| raise "Unknown type 0x%02x at %d" % [node_type, ofs] }
    (0..255).each{|i|
      name = ("get_%02x!" % i).to_sym
      out[i] = name if respond_to?(name)
    }
    out
  end
  def get_header
    case magic = get_u4
    when 0xABCD
      @magic = [0xABCD]
    when 0xABCE
      a = get_u4
      b = get_u4
      raise "Incorrect ESF magic followup" unless a == 0
      @magic = [0xABCE, a, b]
    else
      raise "Incorrect ESF magic: %X" % magic
    end
    with_temp_ofs(get_u4) {
      @node_types = get_node_types
    }
  end
  def get_node_types
    (0...get_u2()).map{ get_ascii.to_sym }
  end
  def inspect
    "EsfParser(#{@ofs})"
  end
  def get_node_type
    @node_types[get_u2]
  end
  def convert_until_ofs!(ofs_end)
    convert_value! while @ofs < ofs_end
  end
  def xml_nested(name)
    if name
      orig, nested = @xmlout, open_xml(name)
      begin
        @xmlout = nested
        yield
      ensure
        @xmlout = orig
        nested.flush
      end
      @xmlout.tag!("xml_include", :path => nested.rel_path)
    else
      yield
    end
  end
  XmlSplit = {
    :CAI_BDI_POOL                  => "bdi_pool/",
    :FACTION                       => "factions/faction",
    :QUAD_TREE_BIT_ARRAY           => "quadtree/",
    :black_shroud_outlines         => "black_shroud",
    :grid_data                     => "grid_data",
    :pathfinding_areas             => "pathfinding_areas",
    :query_info                    => "query_info",
    :region_data                   => "region_data",
    :regions                       => "regions/region",
    :theatre                       => "theatre",
    :UNIT_CLASS_NAME_ALLOCATOR     => 'unit_name_alloc/',
    :REGION                        => 'region/',
    :HEIGHT_FIELD                  => "height_field",
    :BMD_TEXTURES                  => "bmd_textures",
    :GROUND_TYPE_FIELD             => "ground_type_field",
    :SAVE_GAME_HEADER              => "save_game_header/",
    :MAPS                          => "save_game_header/maps",
    :CAMPAIGN_PREOPEN_MAP_INFO     => "preopen_map_info/info",
    :REGION_OWNERSHIPS_BY_THEATRE  => "region_ownership/theater",
    :VICTORY_CONDITION_OPTIONS     => "victory_conditions/faction",
    :CAMPAIGN_ENV                  => "campaign_env/env",
    :CAMPAIGN_SETUP_LOCAL          => "campaign_env/campaign_setup_local",
    :CAMPAIGN_SETUP                => "campaign_env/campaign_setup",
    :CAMPAIGN_MODEL                => "campaign_env/campaign_model",
    :CAMPAIGN_MAP_DATA             => "campaign_env/campaign_map_data",
    :WORLD                         => "campaign_env/world",
    :CAI_INTERFACE                 => "cai_interface/cai",
    :CAI_WORLD                     => "cai_interface/cai_world",
    :CAI_WORLD_FACTIONS            => "cai_factions/faction",
    :CAI_WORLD_REGIONS             => "cai_regions/region",
    :CAI_WORLD_REGION_BOUNDARIES   => "cai_boundaries/boundary",
    :CAI_WORLD_SETTLEMENTS         => "cai_settlements/settlement",
    :CAI_WORLD_BUILDING_SLOTS      => "cai_building_slots/building_slot",
    :CAI_WORLD_REGION_SLOTS        => "cai_region_slots/region_slot",
    :CAI_WORLD_CHARACTERS          => "cai_characters/character",
    :CAI_WORLD_REOURCE_MOBILES     => "cai_armies/army",
    :CAI_WORLD_UNITS               => "cai_units/unit",
    :CAI_WORLD_REGION_HLICS        => "cai_region_hlics/hlics",
    :CAI_INTERFACE_MANAGERS        => "cai_interface_managers/manager",
    :CAMPAIGN_PATHFINDER           => "campaign-pathfinder/",
    :PATHFINDING_GRID              => "campaign-pathfinder/grid",
  }
  def convert_rec!(node_type, version)
    begin
      return send(ConvertSemanticRec[node_type]) if version.nil? && ConvertSemanticRec[node_type]
    rescue SemanticFail => exn
      @ofs = exn.save_ofs
    end
    xml_nested(XmlSplit[node_type]) do
      @xmlout.tag!("rec", :type=>node_type, :version=>version) do
        convert_until_ofs!(get_u4)
      end
    end
  end
  def convert_80!
    node_type   = get_node_type
    version     = get_byte
    version     = nil if version == DefaultVersions[node_type]
    convert_rec!(node_type, version)
  end
  def convert_81!
    node_type = get_node_type
    version   = get_byte
    ofs_end   = get_u4
    count     = get_u4
    version   = nil if version == DefaultVersions[node_type]
    if count == 0
      @xmlout.tag!("ary", :type=>node_type, :version=>version)
    else
      @xmlout.tag!("ary", :type=>node_type, :version=>version) do
        count.times do
          convert_rec!(node_type, nil)
        end
      end
    end
  end
  def convert_value!
    send(@esf_type_handlers[get_byte])
  end
  def get_ofs_bytes
    get_bytes(get_u4 - @ofs)
  end
  def convert!
    @done = false
    @xmlout.tag!("esf", :magic => @magic.join(" ")) do
      @xmlout.tag!("node_types") do
        node_types.each do |n|
          @xmlout.tag!("node_type", :name => n)
        end
      end
      convert_value!
    end
    @xmlout.flush
    @done = true
  end
end

class XMLPrinter
  attr_reader :out_buf, :out_path, :rel_path
  def initialize(out_path, rel_path)
    @out_path = out_path
    @rel_path = rel_path
    @out_fh   = File.open(out_path, 'wb')
    @out_buf  = ""
    @stack    = []
    @indent   = Hash.new{|ht,k| ht[k]=" "*k}
  end
  def flush
    @out_fh.write @out_buf
    @out_buf = ""
  end
  def tag!(name, *args)
    raise ArgumentError.new("Too many arguments") if args.size > 2
    
    attrs_s = ""
    cnt = nil

    if args.size == 2
      attrs_s = attrs_to_s(args[0])
      cnt = args[1]
    elsif args.size == 1
      if args[0].is_a?(Hash)
        attrs_s = attrs_to_s(args[0])
      else
        cnt = args[0]
      end
    end
    
    cnt = nil if cnt == ""

    if block_given?
      raise ArgumentError.new("Cannot use content argument and bolck at the same time") if cnt
      out! "<#{name}#{attrs_s}>"
      @stack << name
      yield
      @stack.pop
      out! "</#{name}>"
    elsif cnt.nil?
      out! "<#{name}#{attrs_s}/>"
    else
      out! "<#{name}#{attrs_s}>#{cnt}</#{name}>"
    end
  end
  def out!(str)
    @out_buf << @indent[@stack.size] << str << "\n"
    flush if @out_buf.size > 1_000_000
  end
  private
  def attrs_to_s(attrs={})
    attrs.to_a.map{|k,v| v.nil? ? "" : " #{k}='#{v.to_s.xml_attr_escape}'"}.join
  end
end

verbose = true
if ARGV[0] == "--quiet"
  ARGV.shift
  verbose = false
end

unless ARGV.size == 2
  STDERR.puts <<EOF
Usage:
  #{$0} input.esf output_dir
To hide progress bar:
  #{$0} --quiet input.esf output_dir
EOF
  exit 1
end

in_file = File.open(ARGV[0], 'rb')
out_dir = ARGV[1]
if File.exist?(out_dir)
  STDERR.puts "#{out_dir} already exists"
  exit 1
end
FileUtils.mkdir_p out_dir

esf = EsfParser.new(in_file, out_dir)
thr = esf.progressbar_thread if verbose
esf.convert!
