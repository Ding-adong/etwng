#!/usr/bin/env ruby

require_relative "dir_builder"
require_relative "xml_printer"
require "pathname"
require "fileutils"

class Float
  def pretty_single
    return self if nan?
    begin
      rv = (100_000.0 * self).round / 100_000.0
      return rv if self != rv and [self].pack("f") == [rv].pack("f")
      self
    rescue
      self
    end
  end
end

class String
  # Escape characters for output as XML attribute values (< > & ' ")
  def xml_escape
    replacements = {"<" => "&lt;", ">" => "&gt;", "&" => "&amp;", "\"" => "&quot;", "'" => "&apos;"}
    gsub(/([<>&\'\"])/) { replacements[$1] }
  end
end

class ModelsNavalDbTable
  attr_reader :version, :guid, :empire, :path, :parsed

  def initialize(path, empire)
    @path = Pathname(path)
    @empire = empire
    @data = open(@path, "rb", &:read)
    @ofs = 0
  end

  def bytes_left
    @data.size - @ofs
  end

  def eof?
    @data.size == @ofs
  end

  def get(n)
    raise "Trying to read past end of file" if bytes_left < n
    rv = @data[@ofs, n]
    @ofs += n
    rv
  end

  def get_u1
    get(1).unpack("C")[0]
  end

  def get_u2
    get(2).unpack("v")[0]
  end

  def get_u4
    get(4).unpack("V")[0]
  end

  def get_i4
    get(4).unpack("l")[0]
  end

  def get_flt
    get(4).unpack("f")[0].pretty_single
  end

  def get_v3
    {x: get_flt, y: get_flt, z: get_flt}
  end

  def get_ary(&blk)
    get_u4.times.map(&blk)
  end

  def get_string
    chars = get(2*get_u2).unpack("v*")
    raise if chars.any?{|i| i == 0 or i >= 128}
    chars.pack("U*")
  end

  def get_ascii
    get(get_u2)
  end

  def parse_db_header!
    if @data[@ofs, 4] == "\xFD\xFE\xFC\xFF".b
      @ofs += 4
      @guid = get_string
    else
      @guid = nil
    end
    if @data[@ofs, 4] == "\xFC\xFD\xFE\xFF".b
      @ofs += 4
      @version = get_u1 + 1
      raise "DB header not recognized" unless get(4) == "\x00\x00\x00\x01".b
    elsif @data[@ofs, 1] == "\x01".b
      @ofs += 1
      @version = 1
    else
      raise "DB header not recognized"
    end
  end

  def get_collision
    {name: get_string, index: get_u4, a: get_v3, b: get_v3, c: get_v3}
  end

  def get_efline
    {name: get_string, action: get_u4, end_a: get_v3, end_b: get_v3, direction: get_v3}
  end

  def get_deck
    {
      name: get_string,
      number: get_u4,
      pieces: get_ary{{
        id: get_u4,
        corners: get_ary{ {x: get_flt, y: get_flt, z: get_flt, type: get_u1} },
        something: 4.times.map{ get_flt }
      }},
    }
  end

  def get_navalcam
    {
      name: get_string,
      matrix4x4: 16.times.map{ get_flt },
    }
  end

  def get_navalcams
     get_ary{ get_navalcam }
  end

  def get_bobby
    {
      bobby_id: get_u4,
      mass: get_flt,
      radius: get_flt,
      x: get_flt,
      y: get_flt,
      z: get_flt,
      breach: {radius: get_flt, x: get_flt, y: get_flt, z: get_flt},
      connections: get_ary{ get_u4 },
    }
  end

  def get_cannon
    {type: get_string, a: get_u4, b: get_u4, c: get_v3, d: get_v3}
  end

  def get_damage_model_part
    {
      name: get_string,
      something: get_ary{ get_string },
      panels: get_ary{ get_ary{ get_v3 }},
    }
  end

  def get_pipe
    type = get_u4
    id = get_u4
    case type
    when 2
      [type, id, get_u4, get_u4, get_v3, get_u4, get_v3]
    when 4
      [type, id, get_u4, get_i4, get_v3, get_v3, get_v3, get_i4, get_v3]
    when 5
      [type, id, get_u4, get_i4, get_v3, get_v3, get_v3, get_v3, get_u4, get_v3]
    else
      require 'pry'; binding.pry
    end
  end

  def get_custom_position_v7
    {
      name: get_string,
      a: get_u4,
      b: get_u4,
      position: [get_v3, get_v3],
    }
  end

  def get_custom_position_v1
    {
      name: get_string,
      a: get_u4,
      position: get_v3,
    }
  end

  def get_steam_info_v7
    [get_string, get_u4, get_string, get_v3, get_v3]
  end

  def get_steam_info_v1
    [get_string, get_u4, get_v3, get_v3]
  end

  def get_model_v1_etw
    {
      name: get_string,
      rigging_path: get_string,
      path: get_string,
      navalcams: get_navalcams,
      buoyancy: get_ary{ get_bobby },
      decks: get_ary{ get_deck },
      pipes: get_ary{ get_pipe },
      cannons: get_ary{ get_cannon },
      damage_model: get_ary{ get_damage_model_part },
      collisions: get_ary{ get_collision },
      custom_positions: get_ary{ get_custom_position_v1 },
      eflines: get_ary{ get_efline },
    }
  end

  def get_model_v1_ntw
    {
      name: get_string,
      rigging_path: get_string,
      path: get_string,
      navalcams: get_navalcams,
      buoyancy: get_ary{ get_bobby },
      decks: get_ary{ get_deck },
      pipes: get_ary{ get_pipe },
      cannons: get_ary{ get_cannon },
      damage_model: get_ary{ get_damage_model_part },
      collisions: get_ary{ get_collision },
      eflines: get_ary{ get_efline },
      custom_positions: get_ary{ get_custom_position_v1 },
      steam_info: get_ary{ get_steam_info_v1 },
    }
  end

  def get_model_v7
    {
      name: get_string,
      rigging_path: get_string,
      zero: get_u1,
      path: get_string,
      navalcams: get_navalcams,
      buoyancy: get_ary{ get_bobby },
      decks: get_ary{ get_deck },
      pipes: get_ary{ get_pipe },
      cannons: get_ary{ get_cannon },
      damage_model: get_ary{ get_damage_model_part },
      collisions: get_ary{ get_collision },
      eflines: get_ary{ get_efline },
      custom_positions: get_ary{ get_custom_position_v7 },
      steam_info: get_ary{ get_steam_info_v7 },
    }
  end

  def get_model_v12
    {
      name: get_ascii,
      rigging_path: get_ascii,
      destruction_paths: get_u1.times{ get_ascii },
      path: get_ascii,
      something: 4.times.map{ get_ascii },
      navalcams: get_navalcams,
      buoyancy: get_ary{ get_bobby },
      decks: get_ary{ get_deck },
      pipes: get_ary{ get_pipe },
      cannons: get_ary{ get_cannon },
      damage_model: get_ary{ get_damage_model_part },
      collisions: get_ary{ get_collision },
      eflines: get_ary{ get_efline },
      custom_positions: get_ary{ get_custom_position_v7 },
      steam_info: get_ary{ get_steam_info_v7 },
    }
  end

  def parse!
    parse_db_header!
    @parsed = case @version
    when 1
      if @empire
        get_ary{ get_model_v1_etw }
      else
        get_ary{ get_model_v1_ntw }
      end
    when 7
      get_ary{ get_model_v7 }
    when 12
      get_ary{ get_model_v12 }
    else
      raise "Unknown table version number #{version}"
    end
    raise "Bytes left at end of file" unless eof?
  end
end

class ModelsNavalUnpacker
  def initialize(path, model)
    @path = Pathname(path)
    @out = DirBuilder.new(@path)
    @model = model
  end

  def run!
    @model.parse!
    @out.open_main_xml do
      @out.xml_printer.tag!("dbtable", "version" => @model.version, "empire" => @model.empire, "guid" => @model.guid) do
        @model.parsed.each do |ship|
          rel_path = @out.open_nested_xml("ship", ship[:name]) do
            out_model! ship
          end
          out!("<xml_include path=\"#{rel_path.xml_escape}\"/>")
        end
      end
    end
  end

  def out_model!(ship)
    tag!("name") { out! ship[:name].xml_escape }
    tag!("rigging_path") { out! ship[:name].xml_escape }
    tag!("zero") { out! ship[:zero].to_s } if ship[:zero]
    if ship[:destruction_paths]
      tag!("destruction_paths") do
        ship[:destruction_paths].each do |destruction_path|
          tag! "destruction_path" do
            out! destruction_path.xml_escape
          end
        end
      end
    end
    tag!("something", Hash[%W[a b c d].zip(ship[:something])]) if ship[:something]
    tag!("navalcams") do
      ship[:navalcams].each do |navalcam|
        tag!("navalcam", "name" => navalcam[:name]) do
          out! navalcam[:matrix4x4][0,4].join(" ")
          out! navalcam[:matrix4x4][4,4].join(" ")
          out! navalcam[:matrix4x4][8,4].join(" ")
          out! navalcam[:matrix4x4][12,4].join(" ")
        end
      end
    end
    tag!("buoyancy") do
      ship[:buoyancy].each do |bobby|
        tag!("bobby",
             "id" => bobby[:bobby_id],
             "mass" => bobby[:mass],
             "radius" => bobby[:radius],
             "x" => bobby[:x],
             "y" => bobby[:y],
             "z" => bobby[:z],
        ) do
          # BREACH
          bobby[:connections].each do |connection|
            tag!("connection", "bobby" => connection)
          end
        end
      end
    end

  # def get_bobby
  #   {
  #     breach: {radius: get_flt, x: get_flt, y: get_flt, z: get_flt},
  #     connections: get_ary{ get_u4 },
  #   }
  # end


      # buoyancy: get_ary{ get_bobby },
      # cannons: get_ary{ get_cannon },
      # collisions: get_ary{ get_collision },
      # custom_positions: get_ary{ get_custom_position_v1 },
      # custom_positions: get_ary{ get_custom_position_v7 },
      # damage_model: get_ary{ get_damage_model_part },
      # decks: get_ary{ get_deck },
      # eflines: get_ary{ get_efline },
      # pipes: get_ary{ get_pipe },
      # something: 4.times.map{ get_ascii },
      # steam_info: get_ary{ get_steam_info_v1 },
      # steam_info: get_ary{ get_steam_info_v7 },


  end

  def out!(*args)
    @out.xml_printer.out!(*args)
  end

  def tag!(*args, &blk)
    @out.xml_printer.tag!(*args, &blk)
  end
end

empire = false
if ARGV[0] == "--empire"
  empire = true
  ARGV.shift
end

unless ARGV.size == 2
  STDERR.puts "Usage: #{$0} [--empire] models_naval_dbtable models_naval_dir"
end

model = ModelsNavalDbTable.new(ARGV[0], empire)
unpacker = ModelsNavalUnpacker.new(ARGV[1], model)
unpacker.run!
