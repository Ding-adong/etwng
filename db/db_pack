#!/usr/bin/env ruby

require "db_schemata"

class DbTsvFile
  attr_reader :schema
  def initialize(file_name, table_name)
    @file_name = file_name
    @table_name = table_name
    @data = File.open(file_name, 'rb', &:readlines).map{|line|
      line.sub(/\r?\n?\z/, "").split(/\t/)
    }
    metadata_line = @data.shift[0]
    @guid = nil
    metadata = metadata_line.strip.split(/\s*,\s*/)

    raise "Metadata line unrecognized: #{metadata_line.inspect}" unless metadata.shift =~ /\Aversion\s+(\d+)/
    @version = $1.to_i
    
    if metadata[0] =~ /\Aguid\s+(\S+)/
      @guid = $1
      metadata.shift
    else
      @guid = nil
    end
    if metadata == ["empty", "no schema"]
      @schema = nil
      @data = []
      return
    elsif metadata != []
      raise "Metadata line unrecognized: #{metadata_line.inspect}"
    end
    labels = @data.shift
    @schema = DbSchemata.instance.get_schema(@table_name, @version, @guid)
  end
  
  def field_to_binary(field_type, field_value)
    case field_type
    when "boolean"
      if field_value == "true"
        "\x01"
      elsif field_value == "false"
        "\x00"
      else
        raise "Expected true/false, got #{field_value}"
      end
    when "float"
      # Works with any of: "123", "123.4", "123,4"
      [field_value.gsub('"', '').sub(",", ".").to_f].pack("f")
    when "int"
      [field_value.gsub('"', '').to_i].pack("l")
    when "short"
      [field_value.gsub('"', '').to_i].pack("v")
    when "string"
      str = eval(field_value).unpack("U*")
      [str.size].pack("v") + str.pack("v*")
    when "optstring"
      str = eval(field_value)
      if str.nil?
        "\x00"
      else
        str = str.unpack("U*")
        "\x01" + [str.size].pack("v") + str.pack("v*")
      end
    when /\Ablob:(\d+)/
      bloblen = $1.to_i
      str = eval(field_value)
      raise "Blob expected to have #{bloblen} bytes, had #{str.size}" unless str.size == bloblen
      str
    else
      warn "Unknown ft/fv #{field_type} #{field_value}"
      "x"
    end
  end
  
  def row_to_binary(row)
    raise "Expected #{@schema.size} elements in row, got #{row.size}" unless @schema.size == row.size
    out = ""
    row.size.times{|i|
      out << field_to_binary(@schema[i][1], row[i])
    }
    out
  end
  
  def guid_to_binary
    if @guid
      guid_str = @guid.unpack("U*")
      "\375\376\374\377" + [guid_str.size].pack("v") + guid_str.pack("v*")
    else
      ""
    end
  end
  
  def version_to_binary
    if @version == 1
      "\x01"
    else
      "\374\375\376\377" + [@version-1].pack("C") + "\000\000\000\001"
    end
  end
  
  def to_binary
    out = guid_to_binary + version_to_binary
    out << [@data.size].pack("V")
    @data.each{|row|
      out << row_to_binary(row)
    }
    out
  end
end

def parse_argv
  # Comma mode doesn't actually do anything here, it works either way
  if ARGV[0] == '--comma'
    comma_mode = true
    ARGV.shift
  else
    comma_mode = false
  end
  
  unless ARGV.size == 2
    STDERR.puts "Usage: #{$0} [--comma] input/ output/"
  end
  
  [Pathname(ARGV[0]), Pathname(ARGV[1]), comma_mode]
end

schemata = DbSchemata.new
source, target, $comma_mode = parse_argv

source.find do |file_name|
  next unless file_name.file?
  table_name = file_name.dirname.basename.to_s
  current_target = Pathname((target+file_name.relative_path_from(source)).to_s.sub(/\.tsv\z/, ""))
  
  file = DbTsvFile.new(file_name, table_name)
  unless file.schema
    STDERR.puts "No schema known for #{file_name}, skipping"
    next
  end
  file_bin = file.to_binary
  FileUtils.mkdir_p current_target.dirname
  File.open(current_target, 'wb'){|fh|
    fh.write file_bin
  }
end
