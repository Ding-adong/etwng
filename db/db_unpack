#!/usr/bin/env ruby

require "db_schemata"

class File
  def self.write(path, content)
    File.open(path, "wb"){|fh| fh.write content}
  end
end

class Float
  def pretty_single
    begin
      rv = (100_000.0 * self).round / 100_000.0
      return rv if self != rv and [self].pack("f") == [rv].pack("f")
      self
    rescue
      self
    end
  end
end

class DbFile
  attr_reader :version, :rows, :data, :file_name, :table_name, :schema
  def initialize(file_name, table_name)
    @file_name = file_name
    @table_name = table_name
    
    @data = File.open(file_name, 'rb', &:read)
    @guid = nil
    if @data[0, 4] == "\375\376\374\377"
      gsz, = @data[4, 2].unpack("v")
      @guid = @data[6, gsz*2].unpack("v*").pack("U*")
      @data = @data[(6+gsz*2)..-1]
    end
    
    if @data[0, 1] == "\x01"
      @version = 1
      @data = @data[1..-1]
    elsif @data[0, 4] == "\374\375\376\377" and @data[5, 4] == "\000\000\000\001"
      @version = @data[4, 1].unpack("C")[0] + 1
      @data = @data[9..-1]
    else
      raise "Unknown file, magic number: #{@data[0, 9].inspect}"
    end
    @rows = @data[0, 4].unpack("V")[0]
    @data = @data[4..-1]
    
    @schema = DbSchemata.instance.get_schema(@table_name, @version, @guid)
  end
  
  def can_convert?
    @schema or empty?
  end
  
  def empty?
    @rows == 0
  end
  
  def get(sz)
    rv = @data[@ofs, sz]
    @ofs += sz
    rv
  end
  
  def get_float
    rv = @data[@ofs, 4].unpack('f')[0]
    @ofs += 4
    rv.pretty_single
  end
  
  def get_byte
    rv = @data[@ofs, 1].unpack("C")[0]
    @ofs += 1
    rv
  end
  
  def get_bool
    case b = get_byte
    when 0
      false
    when 1
      true
    else
      raise "Expected 0 or 1, got #{b}"
    end
  end
  
  def get_u2
    rv = @data[@ofs, 2].unpack('v')[0]
    @ofs += 2
    rv
  end

  def get_i4
    rv = @data[@ofs, 4].unpack('l')[0]
    @ofs += 4
    rv
  end
  
  def get_string
    sz = get_u2
    rv = @data[@ofs, 2*sz].unpack('v*').pack("U*")
    @ofs += 2*sz
    rv
  end
  
  def get_field(field_type)
    case field_type
    when "boolean"
      get_bool
    when "float"
      get_float
    when "int"
      get_i4
    when "short"
      get_u2
    when "string"
      get_string
    when "optstring"
      if get_bool
        get_string
      else
        nil
      end
    when /\Ablob:(\d+)/
      get($1.to_i)
    else
      raise "Unknown type #{field_type}"
    end
  end
  
  def parse_data
    @ofs = 0
    rv = (0...@rows).map{ @schema.map{|name, field_type| get_field(field_type) } }
    raise "Not all data parsed" unless @ofs == @data.size
    rv
  end
  
  def to_tsv
    header = "version #{@version}"
    header << ", schema #{@table_name}" if @schema
    header << ", guid #{@guid}" if @guid
    if !schema
      if empty?
        return "#{header}, empty, no schema\n"
      else
        raise "#{header}, no schema, cannot convert\n"
      end
    end
    data = parse_data
    return [
      header,
      schema.map{|name, field_type| "#{name}(#{field_type})"}.join("\t"),
      *data.map{|row| row.map{|f|
        if f.is_a?(Float)
          float_to_tsv(f)
        else
          f.inspect
        end
      }.join("\t") }
    ].join("\n") + "\n"
  end
  
  def float_to_tsv(f)
    return f.to_i.to_s if f.to_i == f
    if $comma_mode
      f.inspect.sub(".", ",")
    else
      f.inspect
    end
  end
end

def parse_argv
  if ARGV[0] == '--comma'
    comma_mode = true
    ARGV.shift
  else
    comma_mode = false
  end
  
  unless ARGV.size == 2
    STDERR.puts "Usage: #{$0} [--comma] input/ output/"
  end
  
  [Pathname(ARGV[0]), Pathname(ARGV[1]), comma_mode]
end

schemata = DbSchemata.new
source, target, $comma_mode = parse_argv

source.find do |file_name|
  next unless file_name.file?
  table_name = file_name.dirname.basename.to_s
  current_target = Pathname((target+file_name.relative_path_from(source)).to_s + ".tsv")
  
  file = DbFile.new(file_name, table_name)
  if !file.can_convert?
    warn "File #{file_name} cannot be converted, skipping"
    next
  end
  file_tsv = file.to_tsv
  FileUtils.mkdir_p current_target.dirname
  File.write(current_target, file_tsv)
end
