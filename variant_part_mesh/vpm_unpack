#!/usr/bin/ruby

require "pp"

class FormatError < Exception
end

class Float
  def pretty_single
    rv = (((100_000.0 * self).round / 100_000.0) rescue self)
    return rv if [self].pack("f") == [rv].pack("f")
    self
  end
end

class VariantPartMeshUnpacker
  def initialize(file_name)
    @data = File.open(file_name, 'rb', &:read)
    @ofs  = 0
  end
  def size
    @data.size
  end
  def bytes_left
    @data.size - @ofs
  end

  # Basic data formats
  def get(size)
    raise FormatError.new("Not enough bytes: #{size} requested, only #{@data.size-@ofs} available") if size+@ofs > @data.size
    rv = @data[@ofs, size]
    @ofs += size
    rv
  end
  def get_u4
    get(4).unpack("V")[0]
  end
  def get_flt
    get(4).unpack("f")[0].pretty_single
  end
  def get_u2
    get(2).unpack("v")[0]
  end
  # Size in UTF-16 characters, not bytes
  def get_str(size=nil)
    if size
      get(size*2).unpack("v*").pack("U*").sub(/\x00*\z/, "")
    else
      get(get_u2*2).unpack("v*").pack("U*")
    end
  end

  # Mid-level structures
  def get_4x4_matrix
    get(4*16).unpack("f*").map(&:pretty_single)
  end

  # High level structures
  def get_lod_vertex
  	# {
  	# 	half, half, half : position0 x,y,z
  	# 	half : u (texture coordinate, 0.0 to 1.0, wraps around for other values, meaning the texture is repeated twice in the range 0...2)
  	# 	half, half, half : position1 x,y,z
  	# 	half : v (texture coordinate)
  	# 	half, half, half, half : vmmt flags, I don't know what this does or means. Only the first value seems to be used by the game, valid values are 0, 1 and 2
  	# 	packed byte, packed byte, packed byte : normal 0
  	# 	ubyte : bone index 0
  	# 	packed byte, packed byte, packed byte : normal 1
  	# 	ubyte : bone index 1
  	# 	packed byte, packed byte, packed byte : tangent
  	# 	ubyte : weight for bone 0, the other bone's weight is 255 - this
  	# 	packed byte, packed byte, packed byte : binormal
  	# 	ubyte : instance, is probably always 0 in files and only set to something different in game memory when necessary.
  	# }
    get(8+8+8+3+1+3+1+3+1+3+1)
  end
  def get_lod
    vertices_count = get_u4
    vertex_indices_count = get_u4
    raise FormatError.new("Number of triangle indices should be divisible by 3") if vertex_indices_count % 3 != 0

    vertices = (0...vertices_count).map{ get_lod_vertex }
    vertex_indices = (0...vertex_indices_count/3).map{ get(6).unpack("vvv")}

    [vertices, vertex_indices]
  end
  def get_attachment
    {
      :name => get_str(16),
      :matrix => get_4x4_matrix,
      :bone_index => get_u4,
   }
  end
  def get_shader_setting_basic
    {
      :name  => get_str(32),
      :value => get_flt,
    }
  end
  def get_shader_setting_advanced
    name = get_str(32)
    if %W[colourmapfa specfact specfactor].include?(name)
      {:name => name, :full_name => get_str, :data => get(16).unpack("f*").map(&:pretty_single)}
    else
      # All the following are just a single float
      # 'glossfactor'
      # 'specpower'
      # 'specbrightness'
      # 'specfresnelpower'
      # 'fresnelpower'
      # 'offsetv0'
      # 'offsetv1'
      # 'offsetu0'
      # 'offsetu1'
      # 'reflect_factor'
      # 'ambient_factor'
      # 'bumpfactor'
      # 'specularfresnelpower'
      {:name => name, :value => get_flt}
    end
  end
  def parse_type_1
    attachments_count              = get_u4
    lod_levels                     = get_u4
    vertices_count                 = get_u4
    vertex_indices_count           = get_u4
    shader_settings_advanced_count = get_u4
    shader_settings_basic_count    = get_u4

    lods = (0...lod_levels).map{ get_lod }
    attachments = (0...attachments_count).map{ get_attachment }
    shader_settings_basic = (0...shader_settings_basic_count).map{ get_shader_setting_basic }
    shader_settings_advanced = (0...shader_settings_advanced_count).map{ get_shader_setting_advanced }

    {
      :type => 1,

      # :lods => lods,
      :attachments => attachments,
      :shader_settings_basic => shader_settings_basic,
      :shader_settings_advanced => shader_settings_advanced,

      # Are these control only?
      :vertices_count => vertices_count,
      :vertex_indices_count => vertex_indices_count,

      :bytes_left => bytes_left
    }
  end
  def parse
    raise FormatError.new unless get(4) == "VMPF"
    raise FormatError.new unless get_u4 == 0
    format_type = get_u4
    case format_type
    when 0
      warn "Format 0 not yet supported"
      nil
    when 1
      parse_type_1
    when 2
      warn "Format 2 not yet supported"
      nil
    else
      raise FormatError.new "Only known types are 0, 1, and 2, not #{format_type}"
    end
  end
end

samples = Dir["samples/*"].sort_by{|fn| File.size(fn) } # [0, 10]

samples.each do |file_name|
  vpm = VariantPartMeshUnpacker.new(file_name)
  puts "Converting #{file_name}:"
  data = vpm.parse
  out = ""
  PP.pp(data, out, 150)
  puts out
  puts ""
end

__END__
Statistics by type:
     28 {:type=>0}
    246 {:type=>1}
      2 {:type=>2}
